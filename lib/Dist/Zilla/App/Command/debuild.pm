package Dist::Zilla::App::Command::debuild;

use strict;
use warnings;

# ABSTRACT: build debian package

=head1 DESCRIPTION

This command builds sources using dzil and runs debuild on them.

Sources are kept in 'debuild/source'.

With C<--auto> some files in F<debian/> are also autogenerated.

=cut

use Dist::Zilla::App -command;
use autodie qw(:all);

sub abstract { 'build debian package' }

sub opt_spec {
    # these options are propagated to debuild mostly for the tests
    # note than they should be specified as --us and will be transformed to -us because of getopt parsing differences
    ['us'   => "do not sign the source package"],
    ['uc'   => "do not sign the .changes file"],

    ['auto' => 'autogenerate files in debian/'],
}

sub validate_args {
    my ($self, $opt, $args) = @_;
    die 'no args expected' if @$args;
}

sub execute {
    my ($self, $opt, $args) = @_;

    system('rm -rf debuild');
    mkdir('debuild');
    $self->zilla->build_in('debuild/source');

    $self->_auto if $opt->{auto};

    my @debuild_args;
    push @debuild_args, '-us' if $opt->{us};
    push @debuild_args, '-uc' if $opt->{uc};
    system("cd debuild/source && debuild @debuild_args");
}

sub _auto {
	my ($self) = @_;

	my $debian = $self->zilla->built_in->subdir('debian');
	unless( $debian->stat ){
		$self->log('Creating debian/ directory');
		$debian->mkpath() or die "Error creating $debian: $!\n";
	}

	my $compat = $debian->file('compat');
	unless( $compat->stat ){
		$self->log('Writing debian/compat');

		my $fh = $compat->openw();
		$fh->print("7\n");
		$fh->close() or die "I/O error writing $compat: $!\n";
	}

	my $rules = $debian->file('rules');
	unless( $rules->stat ){
		$self->log('Writing debian/rules');

		my $fh = $rules->openw();
		$fh->print('#!/usr/bin/make -f' . "\n\n" . '%:' . "\n\t" . 'dh $@' . "\n");
		$fh->close() or die "I/O error writing $rules: $!\n";

		chmod( 0755, $rules ) or die "Error chmod'ing $rules: $!\n";
	}

	my $control = $debian->file('control');
	unless( $control->stat ){
		my $control_in = $debian->file('control.in');

		$self->log('Writing debian/control' . ($control_in->stat ? ' merged from debian/control.in' : ''));

		my $contents = $self->_generate_control($control_in);

		my $fh = $control->openw();
		$fh->print( $contents );
		$fh->close() or die "I/O error writing $control: $!\n";
	}
}

sub _generate_control {
	my ($self, $control_in)  = @_;

	# Only load when needed because it's only available on debian
	require Debian::Control::FromCPAN;
	require Debian::AptContents;

	my $apt_contents = Debian::AptContents->new( { homedir => "$ENV{HOME}/.dh-make-perl" } );

	my $stash = $self->zilla->stash_named('%Deb');

	my $control = Debian::Control::FromCPAN->new();

	if( $control_in->stat ){
		$control->read($control_in . '');
	}

	my $default_name = 'lib' . lc($self->zilla->name) . '-perl';
	my $default_maint = $self->zilla->authors->[0];
	my $default_homepage = $self->zilla->distmeta->{resources}{homepage};

	my $src = $control->source;

	$src->Source(    $default_name      ) unless defined $src->Source;
	$src->Section(   'perl'             ) unless defined $src->Section;
	$src->Priority(  'optional'         ) unless defined $src->Priority;
	$src->Maintainer( $default_maint    ) unless defined $src->Maintainer;
	$src->Homepage(   $default_homepage ) if not defined $src->Homepage and defined $default_homepage;
	$src->Standards_Version( '3.9.1'    ) unless defined $src->Standards_Version;

	my $has_existing_builddep = @{$src->Build_Depends} > 0 || @{$src->Build_Depends_Indep} > 0;
	$src->Build_Depends( 'debhelper (>= 7)' ) unless $has_existing_builddep;

	# Only create binary package stanza if there aren't any
	# existing ones
	if( $control->binary->Length == 0 ){
		my $pkg = Debian::Control::Stanza::Binary->new( { Package => $default_name } );
		$control->binary->Push( $default_name => $pkg );
	}

	foreach my $pkg ( $control->binary->Values ){
		my $has_existing_depends = @{$pkg->Depends} > 0;

		$pkg->Architecture( $stash->architecture ) unless defined $pkg->Architecture;
		$pkg->Depends->add('${misc:Depends}', '${perl:Depends}') unless $has_existing_depends;
		$pkg->Description( join( "\n ", map { $_ || '.' }
			$self->zilla->abstract,
			@{$stash->desc},
		)) unless defined $pkg->Description;

		$self->_control_add_prereqs($control, $pkg, $apt_contents, runtime => 'requires') unless $has_existing_depends;
		$self->_control_add_prereqs($control, $pkg, $apt_contents, runtime => 'recommends') unless @{$pkg->Recommends} > 0;
		$self->_control_add_prereqs($control, $pkg, $apt_contents, runtime => 'suggests') unless @{$pkg->Suggests} > 0;
		$self->_control_add_prereqs($control, $pkg, $apt_contents, runtime => 'conflicts') unless @{$pkg->Conflicts} > 0;
	}

	# Build-deps are done after binary packages because they
	# influence the decition to use Build-Depends or
	# Build-Depends-Indep
	$self->_control_add_prereqs($control, $src, $apt_contents, build => 'requires') unless $has_existing_builddep;
	$self->_control_add_prereqs($control, $src, $apt_contents, build => 'conflicts') unless @{$src->Build_Conflicts} > 0;

	$control->write( \my $control_str );

	return $control_str;
}

# Helper function for _generate_control that finds debian dependencies
# from dzil prerequisites

sub _control_add_prereqs {
	my( $self, $control, $stanza, $apt_contents, $phase, $relationship ) = @_;
	croak 'invalid phase' unless $phase eq 'build' or $phase eq 'runtime';

	# Find the field in debian/control where we want to put these
	# prereqs

	my $debian_relationship = ucfirst($relationship);
	$debian_relationship = 'Depends' if $debian_relationship eq 'Requires';

	my $control_field;
	if( $phase eq 'build' ){
		$control_field = 'Build_' . $debian_relationship;
		$control_field .= '_Indep' if not $control->is_arch_dep;
		$control_field = $stanza->$control_field;
	}
	else {
		$control_field = $stanza->$debian_relationship;
	}

	# Get the list of required perl modules

	my $prereqs = $self->zilla->prereqs;

	my $requirements = $prereqs->requirements_for($phase, $relationship)->clone;
	if( $phase eq 'build' ){
		$requirements->add_requirements(
			$prereqs->requirements_for($_, $relationship)
		) for qw(configure runtime test);
	}
	$requirements = $requirements->as_string_hash;

	# Special case for the requirement on perl

	if( my $perl_requirement = delete $requirements->{perl} ){
		$perl_requirement = version->parse($perl_requirement)->normal;
		$perl_requirement =~ s/^v//;
		$control_field->add( Debian::Dependency->new(perl => $perl_requirement) );
	}

	# Map modules to debian packages

	my( $packages, $missing_packages ) = $control->find_debs_for_modules( $requirements, $apt_contents );
	if( @$missing_packages ){
		die "Need the following for $phase/$relationship "
		. 'for which there are no debian packages available: '
		. join(', ', @$missing_packages);
	}

	$control_field->add($packages);

	return;
}

1;
