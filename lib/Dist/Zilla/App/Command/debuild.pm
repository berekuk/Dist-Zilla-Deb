package Dist::Zilla::App::Command::debuild;

use strict;
use warnings;

# ABSTRACT: build debian package

=head1 DESCRIPTION

This command builds sources using dzil and runs debuild on them.

Sources are kept in 'debuild/source'.

With C<--auto> some files in F<debian/> are also autogenerated.

=cut

use Dist::Zilla::App -command;
use autodie qw(:all);

sub abstract { 'build debian package' }

sub opt_spec {
    # these options are propagated to debuild mostly for the tests
    # note than they should be specified as --us and will be transformed to -us because of getopt parsing differences
    ['us'   => "do not sign the source package"],
    ['uc'   => "do not sign the .changes file"],

    ['auto' => 'autogenerate files in debian/'],
}

sub validate_args {
    my ($self, $opt, $args) = @_;
    die 'no args expected' if @$args;
}

sub execute {
    my ($self, $opt, $args) = @_;

    system('rm -rf debuild');
    mkdir('debuild');
    $self->zilla->build_in('debuild/source');

    $self->_auto if $opt->{auto};

    my @debuild_args;
    push @debuild_args, '-us' if $opt->{us};
    push @debuild_args, '-uc' if $opt->{uc};
    system("cd debuild/source && debuild @debuild_args");
}

sub _auto {
	my ($self) = @_;

	my $debian = $self->zilla->built_in->subdir('debian');
	unless( $debian->stat ){
		$self->log('Creating debian/ directory');
		$debian->mkpath() or die "Error creating $debian: $!\n";
	}

	my $compat = $debian->file('compat');
	unless( $compat->stat ){
		$self->log('Writing debian/compat');

		my $fh = $compat->openw();
		$fh->print("7\n");
		$fh->close() or die "I/O error writing $compat: $!\n";
	}

	my $rules = $debian->file('rules');
	unless( $rules->stat ){
		$self->log('Writing debian/rules');

		my $fh = $rules->openw();
		$fh->print('#!/usr/bin/make -f' . "\n\n" . '%:' . "\n\t" . 'dh $@' . "\n");
		$fh->close() or die "I/O error writing $rules: $!\n";

		chmod( 0755, $rules ) or die "Error chmod'ing $rules: $!\n";
	}

	my $control = $debian->file('control');
	unless( $control->stat ){
		$self->log('Writing debian/control');

		my $contents = $self->_generate_control();

		my $fh = $control->openw();
		$fh->print( $contents );
		$fh->close() or die "I/O error writing $control: $!\n";
	}
}

sub _generate_control {
	my ($self)  = @_;

	# Only load when needed because it's only available on debian
	require Debian::Control::FromCPAN;
	require Debian::AptContents;

	my $stash = $self->zilla->stash_named('%Deb');

	my $control = Debian::Control::FromCPAN->new();
	$control->source->Source( 'lib' . lc($self->zilla->name) . '-perl' );
	$control->source->Section('perl');
	$control->source->Priority('optional');
	$control->source->Maintainer( $self->zilla->authors->[0] );
	$control->source->Homepage( $self->zilla->distmeta->{resources}{homepage} ) if $self->zilla->distmeta->{resources}{homepage};
	$control->source->Standards_Version( '3.9.1' );
	$control->source->Build_Depends( 'debhelper (>= 7)' );

	my $pkg_name = 'lib' . lc($self->zilla->name) . '-perl';
	my $pkg = Debian::Control::Stanza::Binary->new( { Package => $pkg_name } );
	$control->binary->Push( $pkg_name => $pkg );

	$pkg->Architecture( $stash->architecture );
	$pkg->Depends->add('${misc:Depends}', '${perl:Depends}');
	$pkg->Description( join( "\n ", map { $_ || '.' }
		$self->zilla->abstract,
		@{$stash->desc},
	));

	my $apt_contents = Debian::AptContents->new( { homedir => "$ENV{HOME}/.dh-make-perl" } );

	$self->_control_add_prereqs($control, $apt_contents, build => 'requires');
	$self->_control_add_prereqs($control, $apt_contents, build => 'conflicts');

	$self->_control_add_prereqs($control, $apt_contents, runtime => 'requires');
	$self->_control_add_prereqs($control, $apt_contents, runtime => 'recommends');
	$self->_control_add_prereqs($control, $apt_contents, runtime => 'suggests');
	$self->_control_add_prereqs($control, $apt_contents, runtime => 'conflicts');

	$control->write( \my $control_str );

	return $control_str;
}

# Helper function for _generate_control that finds debian dependencies
# from dzil prerequisites

sub _control_add_prereqs {
	my( $self, $control, $apt_contents, $phase, $relationship ) = @_;
	croak 'invalid phase' unless $phase eq 'build' or $phase eq 'runtime';

	# Find the field in debian/control where we want to put these
	# prereqs

	my $debian_relationship = ucfirst($relationship);
	$debian_relationship = 'Depends' if $debian_relationship eq 'Requires';

	my $control_field;
	if( $phase eq 'build' ){
		$control_field = 'Build_' . $debian_relationship;
		$control_field .= '_Indep' if not $control->is_arch_dep;
		$control_field = $control->source->$control_field;
	}
	else {
		$control_field = $control->binary->Values(0)->$debian_relationship;
	}

	# Get the list of required perl modules

	my $prereqs = $self->zilla->prereqs;

	my $requirements = $prereqs->requirements_for($phase, $relationship)->clone;
	if( $phase eq 'build' ){
		$requirements->add_requirements(
			$prereqs->requirements_for($_, $relationship)
		) for qw(configure runtime test);
	}
	$requirements = $requirements->as_string_hash;

	# Special case for the requirement on perl

	if( my $perl_requirement = delete $requirements->{perl} ){
		$perl_requirement = version->parse($perl_requirement)->normal;
		$perl_requirement =~ s/^v//;
		$control_field->add( Debian::Dependency->new(perl => $perl_requirement) );
	}

	# Map modules to debian packages

	my( $packages, $missing_packages ) = $control->find_debs_for_modules( $requirements, $apt_contents );
	if( @$missing_packages ){
		die "Need the following for $phase/$relationship "
		. 'for which there are no debian packages available: '
		. join(', ', @$missing_packages);
	}

	$control_field->add($packages);

	return;
}

1;
